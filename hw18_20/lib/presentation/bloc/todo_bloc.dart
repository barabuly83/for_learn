import 'package:flutter_bloc/flutter_bloc.dart';

import '../../core/error/failures.dart';
import '../../domain/entities/todo_item.dart';
import '../../domain/repositories/todo_repository.dart';
import 'auth_bloc.dart';
import 'auth_state.dart';
import 'todo_event.dart';
import 'todo_state.dart';

class TodoBloc extends Bloc<TodoEvent, TodoState> {
  TodoBloc({
    required this.todoRepository,
    required this.authBloc,
  }) : super(TodoInitial()) {
    on<CreateTodoEvent>(_onCreateTodo);
    on<LoadTodosEvent>(_onLoadTodos);
    on<ToggleTodoCompleteEvent>(_onToggleTodoComplete);
    on<DeleteTodoEvent>(_onDeleteTodo);
    on<UpdateTodoEvent>(_onUpdateTodo);
    on<TodoErrorEvent>(_onTodoError);
    on<ToggleTodoCompleteErrorEvent>(_onToggleTodoCompleteError);
    on<ToggleTodoCompleteSuccessEvent>(_onToggleTodoCompleteSuccess);
    on<ShowTodoErrorEvent>(_onShowTodoError);
  }

  final TodoRepository todoRepository;
  final AuthBloc authBloc;

  Future<void> _onCreateTodo(
    CreateTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    emit(TodoLoading());

    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    final userId = currentState.user.uid;

    final todo = TodoItem(
      id: '', // ID will be generated by Firestore
      title: event.title,
      description: event.description,
      userId: userId,
    );

    final result = await todoRepository.createTodo(todo);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      createdTodo,
    ) {
      emit(TodoCreated(createdTodo));
      // Automatically reload todos after creating a new one
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onLoadTodos(
    LoadTodosEvent event,
    Emitter<TodoState> emit,
  ) async {
    emit(TodoLoading());

    // Get the current user ID from auth state
    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    final userId = currentState.user.uid;

    final result = await todoRepository.getTodos(userId);

    result.fold(
      (failure) => emit(TodoError(_mapFailureToMessage(failure))),
      (todos) => emit(TodosLoaded(todos)),
    );
  }

  void _onToggleTodoComplete(
    ToggleTodoCompleteEvent event,
    Emitter<TodoState> emit,
  ) {
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Optimistically update the UI immediately
    final updatedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(updatedTodos));

    // Perform the actual toggle operation in background
    todoRepository.toggleTodoComplete(event.todoId).then((
      result,
    ) {
      result.fold(
        (failure) {
          // Revert the optimistic update on failure and show error
          add(
            ToggleTodoCompleteErrorEvent(
              todoId: event.todoId,
              errorMessage: _mapFailureToMessage(failure),
            ),
          );
        },
        (updatedTodo) {
          // Update with the server response (in case it differs)
          add(ToggleTodoCompleteSuccessEvent(updatedTodo));
        },
      );
    });
  }

  void _onTodoError(TodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onShowTodoError(ShowTodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onToggleTodoCompleteError(
    ToggleTodoCompleteErrorEvent event,
    Emitter<TodoState> emit,
  ) {
    // Store current state for reverting
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Revert the optimistic update by toggling back
    final revertedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(revertedTodos));

    // Show error after a brief delay
    Future<void>.delayed(const Duration(milliseconds: 500)).then((_) {
      add(ShowTodoErrorEvent(event.errorMessage));
    });
  }

  void _onToggleTodoCompleteSuccess(
    ToggleTodoCompleteSuccessEvent event,
    Emitter<TodoState> emit,
  ) {
    if (state is TodosLoaded) {
      final currentTodos = (state as TodosLoaded).todos;
      final updatedTodos = currentTodos.map<TodoItem>((todo) {
        return todo.id == event.updatedTodo.id ? event.updatedTodo : todo;
      }).toList();
      emit(TodosLoaded(updatedTodos));
    }
  }

  Future<void> _onDeleteTodo(
    DeleteTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    final result = await todoRepository.deleteTodo(event.todoId);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      _,
    ) {
      emit(TodoDeleted(event.todoId));
      // Reload todos after deletion
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onUpdateTodo(
    UpdateTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    // Get the current todo to preserve other properties
    final todosState = state;
    if (todosState is! TodosLoaded) {
      emit(const TodoError('Не удалось загрузить задачи'));
      return;
    }

    final existingTodo = todosState.todos.firstWhere(
      (todo) => todo.id == event.todoId,
      orElse: () => throw Exception('Todo not found'),
    );

    final updatedTodo = existingTodo.copyWith(
      title: event.title,
      description: event.description,
    );

    final result = await todoRepository.updateTodo(updatedTodo);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      updatedTodo,
    ) {
      emit(TodoUpdated(updatedTodo));
      // Reload todos after update
      add(const LoadTodosEvent());
    });
  }

  String _mapFailureToMessage(Failure failure) {
    // This would be more sophisticated in a real app
    return 'Failed to create todo: ${failure.message}';
  }
}
