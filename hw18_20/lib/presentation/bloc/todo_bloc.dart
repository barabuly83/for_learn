import 'package:flutter_bloc/flutter_bloc.dart';

import '../../core/error/failures.dart';
import '../../domain/entities/todo_item.dart';
import '../../domain/usecases/create_todo.dart';
import '../../domain/usecases/get_todos.dart';
import '../../domain/usecases/toggle_todo_complete.dart';
import 'auth_bloc.dart';
import 'auth_state.dart';
import 'todo_event.dart';
import 'todo_state.dart';

class TodoBloc extends Bloc<TodoEvent, TodoState> {
  TodoBloc({
    required this.createTodo,
    required this.getTodos,
    required this.toggleTodoComplete,
    required this.authBloc,
  }) : super(TodoInitial()) {
    on<CreateTodoEvent>(_onCreateTodo);
    on<LoadTodosEvent>(_onLoadTodos);
    on<ToggleTodoCompleteEvent>(_onToggleTodoComplete);
    on<TodoErrorEvent>(_onTodoError);
    on<ToggleTodoCompleteErrorEvent>(_onToggleTodoCompleteError);
    on<ToggleTodoCompleteSuccessEvent>(_onToggleTodoCompleteSuccess);
    on<ShowTodoErrorEvent>(_onShowTodoError);
  }

  final CreateTodo createTodo;
  final GetTodos getTodos;
  final ToggleTodoComplete toggleTodoComplete;
  final AuthBloc authBloc;

  Future<void> _onCreateTodo(
    CreateTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    emit(TodoLoading());

    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    final userId = currentState.user.id;

    final todo = TodoItem(
      id: '', // ID will be generated by Firestore
      title: event.title,
      description: event.description,
      userId: userId,
    );

    final result = await createTodo(todo);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      createdTodo,
    ) {
      emit(TodoCreated(createdTodo));
      // Automatically reload todos after creating a new one
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onLoadTodos(
    LoadTodosEvent event,
    Emitter<TodoState> emit,
  ) async {
    emit(TodoLoading());

    // Get the current user ID from auth state
    final currentState = authBloc.state;
    if (currentState is! Authenticated) {
      emit(const TodoError('Пользователь должен быть авторизован'));
      return;
    }

    final userId = currentState.user.id;
    final result = await getTodos(GetTodosParams(userId: userId));

    result.fold(
      (failure) => emit(TodoError(_mapFailureToMessage(failure))),
      (todos) => emit(TodosLoaded(todos)),
    );
  }

  void _onToggleTodoComplete(
    ToggleTodoCompleteEvent event,
    Emitter<TodoState> emit,
  ) {
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Optimistically update the UI immediately
    final updatedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(updatedTodos));

    // Perform the actual toggle operation in background
    toggleTodoComplete(ToggleTodoCompleteParams(id: event.todoId)).then((
      result,
    ) {
      result.fold(
        (failure) {
          // Revert the optimistic update on failure and show error
          add(
            ToggleTodoCompleteErrorEvent(
              todoId: event.todoId,
              errorMessage: _mapFailureToMessage(failure),
            ),
          );
        },
        (updatedTodo) {
          // Update with the server response (in case it differs)
          add(ToggleTodoCompleteSuccessEvent(updatedTodo));
        },
      );
    });
  }

  void _onTodoError(TodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onShowTodoError(ShowTodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onToggleTodoCompleteError(
    ToggleTodoCompleteErrorEvent event,
    Emitter<TodoState> emit,
  ) {
    // Store current state for reverting
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Revert the optimistic update by toggling back
    final revertedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(revertedTodos));

    // Show error after a brief delay
    Future<void>.delayed(const Duration(milliseconds: 500)).then((_) {
      add(ShowTodoErrorEvent(event.errorMessage));
    });
  }

  void _onToggleTodoCompleteSuccess(
    ToggleTodoCompleteSuccessEvent event,
    Emitter<TodoState> emit,
  ) {
    if (state is TodosLoaded) {
      final currentTodos = (state as TodosLoaded).todos;
      final updatedTodos = currentTodos.map<TodoItem>((todo) {
        return todo.id == event.updatedTodo.id ? event.updatedTodo : todo;
      }).toList();
      emit(TodosLoaded(updatedTodos));
    }
  }

  String _mapFailureToMessage(Failure failure) {
    // This would be more sophisticated in a real app
    return 'Failed to create todo: ${failure.message}';
  }
}
