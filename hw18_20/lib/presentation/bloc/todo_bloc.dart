import 'dart:async';
import 'package:dartz/dartz.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../core/error/failures.dart';
import '../../domain/entities/todo_item.dart';
import '../../domain/repositories/todo_repository.dart';
import 'auth_bloc.dart';
import 'auth_state.dart';
import 'todo_event.dart';
import 'todo_state.dart';

class TodoBloc extends Bloc<TodoEvent, TodoState> {
  TodoBloc({required this.todoRepository, required this.authBloc})
    : super(const TodoInitial()) {
    on<CreateTodoEvent>(_onCreateTodo);
    on<LoadTodosEvent>(_onLoadTodos);
    on<ToggleTodoCompleteEvent>(_onToggleTodoComplete);
    on<DeleteTodoEvent>(_onDeleteTodo);
    on<UpdateTodoEvent>(_onUpdateTodo);
    on<ReorderTodosEvent>(_onReorderTodos);
    on<TodoErrorEvent>(_onTodoError);
    on<ToggleTodoCompleteErrorEvent>(_onToggleTodoCompleteError);
    on<ToggleTodoCompleteSuccessEvent>(_onToggleTodoCompleteSuccess);
    on<ShowTodoErrorEvent>(_onShowTodoError);
    on<TodosLoadedEvent>(_onTodosLoaded);
  }

  final TodoRepository todoRepository;
  final AuthBloc authBloc;
  StreamSubscription<Either<Failure, List<TodoItem>>>? _todosSubscription;

  Future<void> _onCreateTodo(
    CreateTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    emit(const TodoLoading());

    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('userMustBeAuthenticated'));
      return;
    }

    final userId = currentState.user.uid;

    // Calculate the next order based on current todos
    final currentTodos = state is TodosLoaded
        ? (state as TodosLoaded).todos
        : <TodoItem>[];
    final maxOrder = currentTodos.isEmpty
        ? 0
        : currentTodos.map((t) => t.order).reduce((a, b) => a > b ? a : b);
    final nextOrder = maxOrder + 1;

    final todo = TodoItem(
      id: '', // ID will be generated by Firestore
      title: event.title,
      description: event.description,
      userId: userId,
      order: nextOrder,
    );

    final result = await todoRepository.createTodo(todo);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      createdTodo,
    ) {
      emit(TodoCreated(createdTodo));
      // Automatically reload todos after creating a new one
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onLoadTodos(
    LoadTodosEvent event,
    Emitter<TodoState> emit,
  ) async {
    debugPrint('üìã TodoBloc: Setting up realtime todos listener...');

    // Cancel existing subscription if any
    _todosSubscription?.cancel();

    // Get the current user ID from auth state
    final currentState = authBloc.state;
    debugPrint(
      'üìã TodoBloc: Auth state: ${currentState.runtimeType}, isAuthenticated: ${currentState is Authenticated}',
    );

    if (currentState is! Authenticated) {
      debugPrint(
        '‚ùå TodoBloc: User not authenticated - current state: ${currentState.runtimeType}',
      );
      emit(const TodoError('userMustBeAuthenticated'));
      return;
    }

    final userId = currentState.user.uid;
    debugPrint(
      'üìã TodoBloc: Setting up realtime listener for user: $userId, user email: ${currentState.user.email}',
    );

    emit(const TodoLoading());

    // Set up realtime listener
    _todosSubscription = todoRepository
        .watchTodos(userId)
        .listen(
          (result) {
            result.fold(
              (failure) {
                debugPrint('‚ùå TodoBloc: Realtime error: ${failure.message}');
                add(TodoErrorEvent(_mapFailureToMessage(failure)));
              },
              (todos) {
                debugPrint(
                  '‚úÖ TodoBloc: Realtime update - ${todos.length} todos',
                );
                add(TodosLoadedEvent(todos));
              },
            );
          },
          onError: (Object error) {
            debugPrint('‚ùå TodoBloc: Realtime stream error: $error');
            add(TodoErrorEvent('Failed to watch todos: $error'));
          },
        );
  }

  void _onTodosLoaded(TodosLoadedEvent event, Emitter<TodoState> emit) {
    debugPrint(
      'üìã TodoBloc: Emitting TodosLoaded with ${event.todos.length} todos',
    );
    emit(TodosLoaded(event.todos));
  }

  void _onToggleTodoComplete(
    ToggleTodoCompleteEvent event,
    Emitter<TodoState> emit,
  ) {
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Optimistically update the UI immediately
    final updatedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(updatedTodos));

    // Perform the actual toggle operation in background
    todoRepository.toggleTodoComplete(event.todoId).then((result) {
      result.fold(
        (failure) {
          // Revert the optimistic update on failure and show error
          add(
            ToggleTodoCompleteErrorEvent(
              todoId: event.todoId,
              errorMessage: _mapFailureToMessage(failure),
            ),
          );
        },
        (updatedTodo) {
          // Update with the server response (in case it differs)
          add(ToggleTodoCompleteSuccessEvent(updatedTodo));
        },
      );
    });
  }

  void _onTodoError(TodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onShowTodoError(ShowTodoErrorEvent event, Emitter<TodoState> emit) {
    emit(TodoError(event.message));
  }

  void _onToggleTodoCompleteError(
    ToggleTodoCompleteErrorEvent event,
    Emitter<TodoState> emit,
  ) {
    // Store current state for reverting
    final currentState = state;
    if (currentState is! TodosLoaded) return;

    // Revert the optimistic update by toggling back
    final revertedTodos = currentState.todos.map((todo) {
      if (todo.id == event.todoId) {
        return todo.copyWith(isCompleted: !todo.isCompleted);
      }
      return todo;
    }).toList();

    emit(TodosLoaded(revertedTodos));

    // Show error after a brief delay
    Future<void>.delayed(const Duration(milliseconds: 500)).then((_) {
      add(ShowTodoErrorEvent(event.errorMessage));
    });
  }

  void _onToggleTodoCompleteSuccess(
    ToggleTodoCompleteSuccessEvent event,
    Emitter<TodoState> emit,
  ) {
    if (state is TodosLoaded) {
      final currentTodos = (state as TodosLoaded).todos;
      final updatedTodos = currentTodos.map<TodoItem>((todo) {
        return todo.id == event.updatedTodo.id ? event.updatedTodo : todo;
      }).toList();
      emit(TodosLoaded(updatedTodos));
    }
  }

  Future<void> _onDeleteTodo(
    DeleteTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('userMustBeAuthenticated'));
      return;
    }

    final result = await todoRepository.deleteTodo(event.todoId);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      _,
    ) {
      emit(TodoDeleted(event.todoId));
      // Reload todos after deletion
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onUpdateTodo(
    UpdateTodoEvent event,
    Emitter<TodoState> emit,
  ) async {
    final currentState = authBloc.state;

    if (currentState is! Authenticated) {
      emit(const TodoError('userMustBeAuthenticated'));
      return;
    }

    // Get the current todo to preserve other properties
    final todosState = state;
    if (todosState is! TodosLoaded) {
      emit(const TodoError('failedToLoadTodos'));
      return;
    }

    final existingTodo = todosState.todos.firstWhere(
      (todo) => todo.id == event.todoId,
      orElse: () => throw Exception('Todo not found'),
    );

    final updatedTodo = existingTodo.copyWith(
      title: event.title,
      description: event.description,
    );

    final result = await todoRepository.updateTodo(updatedTodo);

    result.fold((failure) => emit(TodoError(_mapFailureToMessage(failure))), (
      updatedTodo,
    ) {
      emit(TodoUpdated(updatedTodo));
      // Reload todos after update
      add(const LoadTodosEvent());
    });
  }

  Future<void> _onReorderTodos(
    ReorderTodosEvent event,
    Emitter<TodoState> emit,
  ) async {
    final currentState = state;
    if (currentState is! TodosLoaded) {
      return; // Can only reorder when todos are loaded
    }

    try {
      debugPrint(
        'üîÑ TodoBloc: Reordering todos from ${event.oldIndex} to ${event.newIndex}',
      );

      // Create a copy of the current todos list and reorder it
      final reorderedTodos = List<TodoItem>.from(currentState.todos);
      final item = reorderedTodos.removeAt(event.oldIndex);
      reorderedTodos.insert(event.newIndex, item);

      // Emit the reordered list immediately for UI responsiveness
      emit(TodosLoaded(reorderedTodos));

      // Save the new order to the repository
      final result = await todoRepository.reorderTodos(reorderedTodos);

      result.fold(
        (failure) {
          debugPrint(
            '‚ùå TodoBloc: Failed to save reordered todos: ${failure.message}',
          );
          // Revert to original order on failure
          emit(TodosLoaded(currentState.todos));
          emit(TodoError(_mapFailureToMessage(failure)));
        },
        (updatedTodos) {
          debugPrint('‚úÖ TodoBloc: Successfully reordered todos');
          emit(TodosLoaded(updatedTodos));
        },
      );
    } catch (e) {
      debugPrint('‚ùå TodoBloc: Error reordering todos: $e');
      // Revert to original order on error
      emit(TodosLoaded(currentState.todos));
      emit(const TodoError('Failed to reorder todos'));
    }
  }

  String _mapFailureToMessage(Failure failure) {
    // This would be more sophisticated in a real app
    return 'Failed to create todo: ${failure.message}';
  }

  @override
  Future<void> close() async {
    _todosSubscription?.cancel();
    await super.close();
  }
}
